{"version":3,"sources":["webpack:///../node_modules/d3-shape/src/curve/step.js","webpack:///./node_modules/core-js/modules/es.math.hypot.js","webpack:///../node_modules/react-use-gesture/dist/reactusegesture.esm.js","webpack:///../src/components/Brush.tsx","webpack:///./src/pages/brush.tsx","webpack:///../test/fixtures.ts"],"names":["Step","context","t","this","_context","_t","stepBefore","stepAfter","prototype","areaStart","_line","areaEnd","NaN","lineStart","_x","_y","_point","lineEnd","lineTo","closePath","point","x","y","moveTo","x1","$","$hypot","Math","hypot","abs","sqrt","target","stat","forced","Infinity","value1","value2","arg","div","sum","i","aLen","arguments","length","larg","addV","v1","v2","map","v","subV","calculateDistance","movement","apply","calculateAllKinematics","delta","dt","dl","alpha","beta","velocity","velocities","direction","distance","sign","Number","rubberband","dimension","constant","pow","rubberband2","rubberbandIfOutOfBounds","position","min","max","value","minMax","_defineProperties","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_extends","assign","source","hasOwnProperty","call","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","_assertThisInitialized","self","ReferenceError","_arrayLikeToArray","arr","len","arr2","Array","_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","isArray","minLen","n","toString","slice","name","from","test","_unsupportedIterableToArray","done","TypeError","next","bind","noop","chainFns","_len","fns","_key","result","_step","_iterator","fn","ensureVector","fallback","undefined","Error","valueFn","_len2","args","_key2","resolveWith","config","resolvers","_i","_Object$entries","entries","_Object$entries$_i","resolver","supportsTouchEvents","window","getEventTouches","event","type","changedTouches","targetTouches","getTouchIds","identifier","getGenericEventData","buttons","shiftKey","altKey","metaKey","ctrlKey","identity","xy","getPointerEventValues","transform","touchEvents","_ref","clientX","clientY","InternalGestureOptionsNormalizers","threshold","enabled","triggerAllEvents","initial","InternalCoordinatesOptionsNormalizers","axis","lockDirection","bounds","state","_value2","_value2$left","left","_value2$right","right","_value2$top","top","_value2$bottom","bottom","isBrowser","document","createElement","InternalGenericOptionsNormalizers","domTarget","_window","eventOptions","_temp","_ref$passive","passive","_ref$capture","capture","InternalDragOptionsNormalizers","useTouch","experimental_preventWindowScrollY","_k","_ref3","_ref3$filterTaps","filterTaps","_ref3$lockDirection","_ref3$axis","A","swipeVelocity","swipeDistance","swipeDuration","delay","getInternalGenericOptions","getInternalDragOptions","_buildDragConfig","rest","opts","drag","getInitial","mixed","_active","_blocked","_intentional","_movement","_initial","_bounds","_lastEventType","_dragStarted","_dragPreventScroll","_dragIsTap","_dragDelayed","intentional","values","offset","lastOffset","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","getInitialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","touches","down","locked","_pointerId","vxvy","tap","swipe","pinch","_pointerIds","da","vdva","origin","turns","wheel","move","scroll","RecognizersMap","Map","identity$1","Recognizer","controller","_this","debounced","setTimeout","callback","ms","clearTimeout","timeouts","stateKey","concat","fireGestureHandler","forceFlag","clean","prev_active","next_active","ingKey","pointerIds","size","touchIds","mapStateValues","pointerLockElement","newMemo","handler","Constructor","protoProps","staticProps","_proto","updateSharedState","sharedState","updateGestureState","gestureState","checkIntentionality","getMovement","_this$config","T","_this$state","wasIntentional","prevMovement","M","getInternalMovement","_T","i0","getIntentionalDisplacement","i1","intentionalityCheck","_rubberband","computeRubberband","get","handlers","_ref2","Vx","Vy","Rx","Ry","_bounds$","X1","X2","_bounds$2","Y1","Y2","getGenericPayload","isStartEvent","getStartGestureState","_ref4","_state","Controller","classes","Set","supportsGestureEvents","GestureEvent","e","bindings","RecognizerClass","addBindings","_loop","eventKey","nativeRefs","updateDomListeners","getPropsListener","effect","getDomTargetFromConfig","removeListeners","takeAll","domListeners","forEach","_controller$config","el","windowListeners","clearAllWindowListeners","addEventIds","add","pointerId","removeEventIds","id","clearWindowListeners","options","updateWindowListeners","listeners","addListeners","toLowerCase","push","captureString","_i2","_Object$entries2","_Object$entries2$_i","fnsArray","array","splice","_ref5","current","_step2","_iterator2","_step2$value","eventName","eventHandler","addEventListener","_step3","_iterator3","_step3$value","removeEventListener","useRecognizers","nativeHandlers","internalHandlers","hover","resolveClasses","useMemo","useEffect","deprecationNoticeForDomTarget","CoordinatesRecognizer","_Recognizer","_movement$map","absX","absY","getKinematics","persistEvent","persist","DragRecognizer","_CoordinatesRecognize","setPointerCapture","_dragTarget","_dragPointerId","releasePointerCapture","hasPointerCapture","preventScroll","cancelable","preventDefault","getEventId","isValidEvent","shouldPreventWindowScrollY","setUpWindowScrollDetection","startDrag","setUpDelayedDragTrigger","setStartState","onDragStart","onDragChange","movementX","movementY","kinematics","genericEventData","genericPayload","realDistance","onDragEnd","_this$state$velocitie","vx","vy","_this$state$movement","mx","my","_this$state$_intentio","ix","iy","_this$config$swipeVel","svx","svy","_this$config$swipeDis","sx","sy","sd","endState","onCancel","onClick","stopPropagation","onDragIsStart","memoizeOne","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","a","b","equal","has","RegExp","flags","valueOf","Element","$$typeof","error","message","match","console","warn","useDrag","set","buildDragConfig","Container","children","height","width","fill","Brush","onChange","brushWidth","chart","initialPosition","start","w","useState","end","bindResizeLeft","bindResizeRight","rect","style","cursor","opacity","dateFormat","scale","label","numberFormat","filterData","pos","data","data3","line","LineExample","useWidth","ref","scaleTime","domain","range","filter","brushedData","setBrushedData","title","description","Typography","variant","Grid","container","spacing","className","item","xs","md","Card","CardContent","Line","animate","makeBrushedData","now","Date","dateValues","_","setDate","getDate","lineChartData","curveType","curveStepBefore","curveCatmullRom","show","stroke","radius","tornadoData","bins","counts","scatterData","z","radarData","axes"],"mappings":"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","file":"component---src-pages-brush-tsx-ad6993893c7b082f996b.js","sourcesContent":["function Step(context, t) {\n  this._context = context;\n  this._t = t;\n}\n\nStep.prototype = {\n  areaStart: function areaStart() {\n    this._line = 0;\n  },\n  areaEnd: function areaEnd() {\n    this._line = NaN;\n  },\n  lineStart: function lineStart() {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function lineEnd() {\n    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);\n    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();\n    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;\n  },\n  point: function point(x, y) {\n    x = +x, y = +y;\n\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n        break;\n\n      case 1:\n        this._point = 2;\n      // proceed\n\n      default:\n        {\n          if (this._t <= 0) {\n            this._context.lineTo(this._x, y);\n\n            this._context.lineTo(x, y);\n          } else {\n            var x1 = this._x * (1 - this._t) + x * this._t;\n\n            this._context.lineTo(x1, this._y);\n\n            this._context.lineTo(x1, y);\n          }\n\n          break;\n        }\n    }\n\n    this._x = x, this._y = y;\n  }\n};\nexport default function (context) {\n  return new Step(context, 0.5);\n}\nexport function stepBefore(context) {\n  return new Step(context, 0);\n}\nexport function stepAfter(context) {\n  return new Step(context, 1);\n}","var $ = require('../internals/export');\n\nvar $hypot = Math.hypot;\nvar abs = Math.abs;\nvar sqrt = Math.sqrt;\n\n// Chrome 77 bug\n// https://bugs.chromium.org/p/v8/issues/detail?id=9546\nvar BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;\n\n// `Math.hypot` method\n// https://tc39.es/ecma262/#sec-math.hypot\n$({ target: 'Math', stat: true, forced: BUGGY }, {\n  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * sqrt(sum);\n  }\n});\n","import \"core-js/modules/es.math.hypot.js\";\nimport React, { useRef } from 'react'; // vector add\n\nfunction addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n} // vector substract\n\n\nfunction subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */\n\n\nfunction calculateDistance(movement) {\n  return Math.hypot.apply(Math, movement);\n}\n\nfunction calculateAllGeometry(movement, delta) {\n  if (delta === void 0) {\n    delta = movement;\n  }\n\n  var dl = calculateDistance(delta);\n  var alpha = dl === 0 ? 0 : 1 / dl;\n  var direction = delta.map(function (v) {\n    return alpha * v;\n  });\n  var distance = calculateDistance(movement);\n  return {\n    distance: distance,\n    direction: direction\n  };\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\n\nfunction calculateAllKinematics(movement, delta, dt) {\n  var dl = calculateDistance(delta);\n  var alpha = dl === 0 ? 0 : 1 / dl;\n  var beta = dt === 0 ? 0 : 1 / dt;\n  var velocity = beta * dl;\n  var velocities = delta.map(function (v) {\n    return beta * v;\n  });\n  var direction = delta.map(function (v) {\n    return alpha * v;\n  });\n  var distance = calculateDistance(movement);\n  return {\n    velocities: velocities,\n    velocity: velocity,\n    distance: distance,\n    direction: direction\n  };\n}\n/**\r\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\r\n * This polyfill function is suggested by Mozilla:\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\r\n * @param x target number\r\n */\n\n\nfunction sign(x) {\n  if (Math.sign) return Math.sign(x);\n  return Number(x > 0) - Number(x < 0) || +x;\n}\n\nfunction minMax(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n} // Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\n\n\nfunction rubberband2(distance, constant) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5);\n}\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant) {\n  if (constant === void 0) {\n    constant = 0.15;\n  }\n\n  if (constant === 0) return minMax(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction noop() {}\n/**\r\n * TODO Beware that only optimized cases are covered in tests =)\r\n * TODO Need to cover general case as well\r\n *\r\n * @param fns\r\n */\n\n\nfunction chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    var result;\n\n    for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {\n      var fn = _step.value;\n      result = fn.apply(this, arguments) || result;\n    }\n\n    return result;\n  };\n}\n/**\r\n * Expects a simple value or 2D vector (an array with 2 elements) and\r\n * always returns 2D vector. If simple value is passed, returns a\r\n * vector with this value as both coordinates.\r\n *\r\n * @param value\r\n */\n\n\nfunction ensureVector(value, fallback) {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected');\n    }\n\n    value = fallback;\n  }\n\n  if (Array.isArray(value)) return value;\n  return [value, value];\n}\n/**\r\n * Helper for defining a default value\r\n *\r\n * @param value\r\n * @param fallback\r\n */\n\n\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n/**\r\n * Resolves getters (functions) by calling them\r\n * If simple value is given it just passes through\r\n *\r\n * @param v\r\n */\n\n\nfunction valueFn(v) {\n  if (typeof v === 'function') {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    } // @ts-ignore\n\n\n    return v.apply(void 0, args);\n  } else {\n    return v;\n  }\n}\n\nfunction resolveWith(config, resolvers) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var result = {};\n\n  for (var _i = 0, _Object$entries = Object.entries(resolvers); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _Object$entries[_i],\n        key = _Object$entries$_i[0],\n        resolver = _Object$entries$_i[1];\n\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config);\n        break;\n\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n\n  return result;\n}\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\n\nfunction supportsGestureEvents() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction supportsTouchEvents() {\n  return typeof window !== 'undefined' && 'ontouchstart' in window;\n}\n\nfunction getEventTouches(event) {\n  if ('pointerId' in event) return null;\n  return event.type === 'touchend' ? event.changedTouches : event.targetTouches;\n}\n\nfunction getTouchIds(event) {\n  return Array.from(getEventTouches(event)).map(function (t) {\n    return t.identifier;\n  });\n}\n\nfunction getGenericEventData(event) {\n  var buttons = 'buttons' in event ? event.buttons : 0;\n  var shiftKey = event.shiftKey,\n      altKey = event.altKey,\n      metaKey = event.metaKey,\n      ctrlKey = event.ctrlKey; // TODO check if this might create some overrides?\n\n  return {\n    buttons: buttons,\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\n\nvar identity = function identity(xy) {\n  return xy;\n};\n/**\r\n * Gets pointer event values.\r\n * @param event\r\n * @returns pointer event values\r\n */\n\n\nfunction getPointerEventValues(event, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n\n  var touchEvents = getEventTouches(event);\n\n  var _ref = touchEvents ? touchEvents[0] : event,\n      clientX = _ref.clientX,\n      clientY = _ref.clientY;\n\n  return transform([clientX, clientY]);\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\n\nfunction getTwoTouchesEventValues(event, pointerIds, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n\n  var _Array$from$filter = Array.from(event.touches).filter(function (t) {\n    return pointerIds.includes(t.identifier);\n  }),\n      A = _Array$from$filter[0],\n      B = _Array$from$filter[1];\n\n  if (!A || !B) throw Error(\"The event doesn't have two pointers matching the pointerIds\");\n  var dx = B.clientX - A.clientX;\n  var dy = B.clientY - A.clientY;\n  var cx = (B.clientX + A.clientX) / 2;\n  var cy = (B.clientY + A.clientY) / 2; // const e: any = 'nativeEvent' in event ? event.nativeEvent : event\n\n  var distance = Math.hypot(dx, dy); // FIXME rotation has inconsistant values so we're not using it atm\n  // const angle = (e.rotation as number) ?? -(Math.atan2(dx, dy) * 180) / Math.PI\n\n  var angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  var values = transform([distance, angle]);\n  var origin = transform([cx, cy]);\n  return {\n    values: values,\n    origin: origin\n  };\n}\n/**\r\n * Gets scroll event values\r\n * @param event\r\n * @returns scroll event values\r\n */\n\n\nfunction getScrollEventValues(event, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  } // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n\n\n  var _event$currentTarget = event.currentTarget,\n      scrollX = _event$currentTarget.scrollX,\n      scrollY = _event$currentTarget.scrollY,\n      scrollLeft = _event$currentTarget.scrollLeft,\n      scrollTop = _event$currentTarget.scrollTop;\n  return transform([scrollX || scrollLeft || 0, scrollY || scrollTop || 0]);\n} // wheel delta defaults from https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\n\n\nvar LINE_HEIGHT = 40;\nvar PAGE_HEIGHT = 800;\n/**\r\n * Gets wheel event values.\r\n * @param event\r\n * @returns wheel event values\r\n */\n\nfunction getWheelEventValues(event, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n\n  var deltaX = event.deltaX,\n      deltaY = event.deltaY,\n      deltaMode = event.deltaMode; // normalize wheel values, especially for Firefox\n\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n\n  return transform([deltaX, deltaY]);\n}\n/**\r\n * Gets webkit gesture event values.\r\n * @param event\r\n * @returns webkit gesture event values\r\n */\n\n\nfunction getWebkitGestureEventValues(event, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n\n  return transform([event.scale, event.rotation]);\n}\n\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_RUBBERBAND = 0.15;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 50;\nvar DEFAULT_SWIPE_DURATION = 250;\nvar InternalGestureOptionsNormalizers = {\n  threshold: function threshold(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    return ensureVector(value);\n  },\n  rubberband: function rubberband(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND);\n\n      case false:\n        return ensureVector(0);\n\n      default:\n        return ensureVector(value);\n    }\n  },\n  enabled: function enabled(value) {\n    if (value === void 0) {\n      value = true;\n    }\n\n    return value;\n  },\n  triggerAllEvents: function triggerAllEvents(value) {\n    if (value === void 0) {\n      value = false;\n    }\n\n    return value;\n  },\n  initial: function initial(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    if (typeof value === 'function') return value;\n    return ensureVector(value);\n  },\n  transform: true\n};\n\nvar InternalCoordinatesOptionsNormalizers = /*#__PURE__*/_extends({}, InternalGestureOptionsNormalizers, {\n  axis: true,\n  lockDirection: function lockDirection(value) {\n    if (value === void 0) {\n      value = false;\n    }\n\n    return value;\n  },\n  bounds: function bounds(value) {\n    if (value === void 0) {\n      value = {};\n    }\n\n    if (typeof value === 'function') return function (state) {\n      return InternalCoordinatesOptionsNormalizers.bounds(value(state));\n    };\n    var _value2 = value,\n        _value2$left = _value2.left,\n        left = _value2$left === void 0 ? -Infinity : _value2$left,\n        _value2$right = _value2.right,\n        right = _value2$right === void 0 ? Infinity : _value2$right,\n        _value2$top = _value2.top,\n        top = _value2$top === void 0 ? -Infinity : _value2$top,\n        _value2$bottom = _value2.bottom,\n        bottom = _value2$bottom === void 0 ? Infinity : _value2$bottom;\n    return [[left, right], [top, bottom]];\n  }\n});\n\nvar isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\nvar InternalGenericOptionsNormalizers = {\n  enabled: function enabled(value) {\n    if (value === void 0) {\n      value = true;\n    }\n\n    return value;\n  },\n  domTarget: true,\n  window: /*#__PURE__*/function (_window) {\n    function window(_x) {\n      return _window.apply(this, arguments);\n    }\n\n    window.toString = function () {\n      return _window.toString();\n    };\n\n    return window;\n  }(function (value) {\n    if (value === void 0) {\n      value = isBrowser ? window : undefined;\n    }\n\n    return value;\n  }),\n  eventOptions: function eventOptions(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$passive = _ref.passive,\n        passive = _ref$passive === void 0 ? true : _ref$passive,\n        _ref$capture = _ref.capture,\n        capture = _ref$capture === void 0 ? false : _ref$capture;\n\n    return {\n      passive: passive,\n      capture: capture\n    };\n  },\n  transform: true\n};\n\nvar InternalDistanceAngleOptionsNormalizers = /*#__PURE__*/_extends({}, InternalGestureOptionsNormalizers, {\n  bounds: function bounds(_value, _key, _ref2) {\n    var _ref2$distanceBounds = _ref2.distanceBounds,\n        distanceBounds = _ref2$distanceBounds === void 0 ? {} : _ref2$distanceBounds,\n        _ref2$angleBounds = _ref2.angleBounds,\n        angleBounds = _ref2$angleBounds === void 0 ? {} : _ref2$angleBounds;\n\n    var _distanceBounds = function _distanceBounds(state) {\n      var D = assignDefault(valueFn(distanceBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n\n    var _angleBounds = function _angleBounds(state) {\n      var A = assignDefault(valueFn(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function') return [_distanceBounds(), _angleBounds()];\n    return function (state) {\n      return [_distanceBounds(state), _angleBounds(state)];\n    };\n  }\n});\n\nvar InternalDragOptionsNormalizers = /*#__PURE__*/_extends({}, InternalCoordinatesOptionsNormalizers, {\n  useTouch: function useTouch(value) {\n    if (value === void 0) {\n      value = false;\n    }\n\n    return value && supportsTouchEvents();\n  },\n  experimental_preventWindowScrollY: function experimental_preventWindowScrollY(value) {\n    if (value === void 0) {\n      value = false;\n    }\n\n    return value;\n  },\n  threshold: function threshold(v, _k, _ref3) {\n    var _ref3$filterTaps = _ref3.filterTaps,\n        filterTaps = _ref3$filterTaps === void 0 ? false : _ref3$filterTaps,\n        _ref3$lockDirection = _ref3.lockDirection,\n        lockDirection = _ref3$lockDirection === void 0 ? false : _ref3$lockDirection,\n        _ref3$axis = _ref3.axis,\n        axis = _ref3$axis === void 0 ? undefined : _ref3$axis;\n    var A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    return A;\n  },\n  swipeVelocity: function swipeVelocity(v) {\n    if (v === void 0) {\n      v = DEFAULT_SWIPE_VELOCITY;\n    }\n\n    return ensureVector(v);\n  },\n  swipeDistance: function swipeDistance(v) {\n    if (v === void 0) {\n      v = DEFAULT_SWIPE_DISTANCE;\n    }\n\n    return ensureVector(v);\n  },\n  swipeDuration: function swipeDuration(value) {\n    if (value === void 0) {\n      value = DEFAULT_SWIPE_DURATION;\n    }\n\n    return value;\n  },\n  delay: function delay(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n\n      case false:\n        return 0;\n\n      default:\n        return value;\n    }\n  }\n});\n\nfunction getInternalGenericOptions(config) {\n  if (config === void 0) {\n    config = {};\n  } // TODO warn when passive is set to true and domTarget is undefined\n\n\n  return resolveWith(config, InternalGenericOptionsNormalizers);\n}\n\nfunction getInternalCoordinatesOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return resolveWith(config, InternalCoordinatesOptionsNormalizers);\n}\n\nfunction getInternalDistanceAngleOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return resolveWith(config, InternalDistanceAngleOptionsNormalizers);\n}\n\nfunction getInternalDragOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return resolveWith(config, InternalDragOptionsNormalizers);\n}\n\nfunction _buildMoveConfig(_ref) {\n  var domTarget = _ref.domTarget,\n      eventOptions = _ref.eventOptions,\n      window = _ref.window,\n      enabled = _ref.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.move = getInternalCoordinatesOptions(rest);\n  return opts;\n}\n\nfunction _buildHoverConfig(_ref2) {\n  var domTarget = _ref2.domTarget,\n      eventOptions = _ref2.eventOptions,\n      window = _ref2.window,\n      enabled = _ref2.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref2, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.hover = _extends({\n    enabled: true\n  }, rest);\n  return opts;\n}\n\nfunction _buildDragConfig(_ref3) {\n  var domTarget = _ref3.domTarget,\n      eventOptions = _ref3.eventOptions,\n      window = _ref3.window,\n      enabled = _ref3.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref3, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.drag = getInternalDragOptions(rest);\n  return opts;\n}\n\nfunction _buildPinchConfig(_ref4) {\n  var domTarget = _ref4.domTarget,\n      eventOptions = _ref4.eventOptions,\n      window = _ref4.window,\n      enabled = _ref4.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref4, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.pinch = getInternalDistanceAngleOptions(rest);\n  return opts;\n}\n\nfunction _buildScrollConfig(_ref5) {\n  var domTarget = _ref5.domTarget,\n      eventOptions = _ref5.eventOptions,\n      window = _ref5.window,\n      enabled = _ref5.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref5, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.scroll = getInternalCoordinatesOptions(rest);\n  return opts;\n}\n\nfunction _buildWheelConfig(_ref6) {\n  var domTarget = _ref6.domTarget,\n      eventOptions = _ref6.eventOptions,\n      window = _ref6.window,\n      enabled = _ref6.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref6, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.wheel = getInternalCoordinatesOptions(rest);\n  return opts;\n}\n\nfunction buildComplexConfig(config, actions) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  if (actions === void 0) {\n    actions = new Set();\n  }\n\n  var _config = config,\n      drag = _config.drag,\n      wheel = _config.wheel,\n      move = _config.move,\n      scroll = _config.scroll,\n      pinch = _config.pinch,\n      hover = _config.hover,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      transform = _config.transform,\n      domTarget = _config.domTarget,\n      enabled = _config.enabled;\n  var mergedConfig = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    transform: transform,\n    window: window,\n    enabled: enabled\n  });\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag);\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel);\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll);\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move);\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch);\n  if (actions.has('onHover')) mergedConfig.hover = _extends({\n    enabled: true\n  }, hover);\n  return mergedConfig;\n}\n\nfunction getInitial(mixed) {\n  return _extends({\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [[-Infinity, Infinity], [-Infinity, Infinity]],\n    _lastEventType: undefined,\n    _dragStarted: false,\n    _dragPreventScroll: false,\n    _dragIsTap: true,\n    _dragDelayed: false,\n    event: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined\n  }, mixed);\n}\n\nfunction getInitialState() {\n  var shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n    locked: false\n  };\n  var drag = getInitial({\n    _pointerId: undefined,\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0,\n    tap: false,\n    swipe: [0, 0]\n  });\n  var pinch = getInitial({\n    // @ts-expect-error when used _pointerIds we can assert its type will be [number, number]\n    _pointerIds: [],\n    da: [0, 0],\n    vdva: [0, 0],\n    // @ts-expect-error origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0\n  });\n  var wheel = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  var move = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  var scroll = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  return {\n    shared: shared,\n    drag: drag,\n    pinch: pinch,\n    wheel: wheel,\n    move: move,\n    scroll: scroll\n  };\n}\n\nvar RecognizersMap = /*#__PURE__*/new Map();\n\nvar identity$1 = function identity(xy) {\n  return xy;\n};\n/**\r\n * @private\r\n * Recognizer abstract class.\r\n */\n\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param stateKey drag, move, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */\n  function Recognizer(controller, args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = [];\n    }\n\n    this.controller = controller;\n    this.args = args;\n    this.debounced = true; // Convenience method to set a timeout for a given gesture\n\n    this.setTimeout = function (callback, ms) {\n      var _window;\n\n      if (ms === void 0) {\n        ms = 140;\n      }\n\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n    }; // Convenience method to clear a timeout for a given gesture\n\n\n    this.clearTimeout = function () {\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n    };\n    /**\r\n     * Fires the gesture handler\r\n     */\n\n\n    this.fireGestureHandler = function (forceFlag) {\n      if (forceFlag === void 0) {\n        forceFlag = false;\n      }\n      /**\r\n       * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\r\n       * clean everything and don't do anything.\r\n       */\n\n\n      if (_this.state._blocked) {\n        // we need debounced gestures to end by themselves\n        if (!_this.debounced) {\n          _this.state._active = false;\n\n          _this.clean();\n        }\n\n        return null;\n      } // If the gesture has no intentional dimension, don't fire the handler.\n\n\n      if (!forceFlag && !_this.state.intentional && !_this.config.triggerAllEvents) return null;\n\n      if (_this.state.intentional) {\n        var prev_active = _this.state.active;\n        var next_active = _this.state._active;\n        _this.state.active = next_active;\n        _this.state.first = next_active && !prev_active;\n        _this.state.last = prev_active && !next_active;\n        _this.controller.state.shared[_this.ingKey] = next_active; // Sets dragging, pinching, etc. to the gesture active state\n      }\n\n      var touches = _this.controller.pointerIds.size || _this.controller.touchIds.size;\n      var down = _this.controller.state.shared.buttons > 0 || touches > 0;\n\n      var state = _extends({}, _this.controller.state.shared, _this.state, _this.mapStateValues(_this.state), {\n        locked: !!document.pointerLockElement,\n        touches: touches,\n        down: down\n      }); // @ts-expect-error\n\n\n      var newMemo = _this.handler(state); // Sets memo to the returned value of the handler (unless it's not undefined)\n\n\n      _this.state.memo = newMemo !== void 0 ? newMemo : _this.state.memo;\n      return state;\n    };\n\n    this.controller = controller;\n    this.args = args;\n  } // Returns the gesture config\n\n\n  var _proto = Recognizer.prototype; // Convenience method to update the shared state\n\n  _proto.updateSharedState = function updateSharedState(sharedState) {\n    Object.assign(this.controller.state.shared, sharedState);\n  } // Convenience method to update the gesture state\n  ;\n\n  _proto.updateGestureState = function updateGestureState(gestureState) {\n    Object.assign(this.state, gestureState);\n  }\n  /**\r\n   * Returns state properties depending on the movement and state.\r\n   *\r\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\r\n   * below.\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n    return {\n      _intentional: _intentional,\n      _blocked: false\n    };\n  }\n  /**\r\n   * Returns basic movement properties for the gesture based on the next values and current state.\r\n   */\n  ;\n\n  _proto.getMovement = function getMovement(values) {\n    var _this$config = this.config,\n        rubberband = _this$config.rubberband,\n        T = _this$config.threshold;\n    var _this$state = this.state,\n        _bounds = _this$state._bounds,\n        _initial = _this$state._initial,\n        _active = _this$state._active,\n        wasIntentional = _this$state._intentional,\n        lastOffset = _this$state.lastOffset,\n        prevMovement = _this$state.movement;\n    var M = this.getInternalMovement(values, this.state);\n\n    var _T = this.transform(T).map(Math.abs);\n\n    var i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], _T[0]) : wasIntentional[0];\n    var i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], _T[1]) : wasIntentional[1]; // Get gesture specific state properties based on intentionality and movement.\n\n    var intentionalityCheck = this.checkIntentionality([i0, i1], M);\n\n    if (intentionalityCheck._blocked) {\n      return _extends({}, intentionalityCheck, {\n        _movement: M,\n        delta: [0, 0]\n      });\n    }\n\n    var _intentional = intentionalityCheck._intentional;\n    var _movement = M;\n    /**\r\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\r\n     * It is calculated from the actual movement minus the threshold.\r\n     */\n\n    var movement = [_intentional[0] !== false ? M[0] - _intentional[0] : 0, _intentional[1] !== false ? M[1] - _intentional[1] : 0];\n    var offset = addV(movement, lastOffset);\n    /**\r\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\r\n     * and offset can return within their bounds.\r\n     */\n\n    var _rubberband = _active ? rubberband : [0, 0];\n\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband);\n    return _extends({}, intentionalityCheck, {\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial: _initial,\n      _movement: _movement,\n      movement: movement,\n      values: values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement)\n    });\n  } // Cleans the gesture. Can be overriden by gestures.\n  ;\n\n  _proto.clean = function clean() {\n    this.clearTimeout();\n  };\n\n  _createClass(Recognizer, [{\n    key: \"config\",\n    get: function get() {\n      return this.controller.config[this.stateKey];\n    } // Is the gesture enabled\n\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return this.controller.config.enabled && this.config.enabled;\n    } // Returns the controller state for a given gesture\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.controller.state[this.stateKey];\n    } // Returns the gesture handler\n\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this.controller.handlers[this.stateKey];\n    }\n  }, {\n    key: \"transform\",\n    get: function get() {\n      return this.config.transform || this.controller.config.transform || identity$1;\n    }\n  }]);\n\n  return Recognizer;\n}(); //--------------------------------------------\n\n\nfunction getIntentionalDisplacement(movement, threshold) {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold;\n  } else {\n    return false;\n  }\n}\n\nfunction computeRubberband(bounds, _ref, _ref2) {\n  var Vx = _ref[0],\n      Vy = _ref[1];\n  var Rx = _ref2[0],\n      Ry = _ref2[1];\n  var _bounds$ = bounds[0],\n      X1 = _bounds$[0],\n      X2 = _bounds$[1],\n      _bounds$2 = bounds[1],\n      Y1 = _bounds$2[0],\n      Y2 = _bounds$2[1];\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)];\n}\n/**\r\n * Returns a generic, common payload for all gestures from an event.\r\n */\n\n\nfunction getGenericPayload(_ref3, event, isStartEvent) {\n  var state = _ref3.state;\n  var timeStamp = event.timeStamp,\n      _lastEventType = event.type;\n  var previous = state.values;\n  var elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime;\n  return {\n    _lastEventType: _lastEventType,\n    event: event,\n    timeStamp: timeStamp,\n    elapsedTime: elapsedTime,\n    previous: previous\n  };\n}\n/**\r\n * Returns the reinitialized start state for the gesture.\r\n * Should be common to all gestures.\r\n */\n\n\nfunction getStartGestureState(_ref4, values, event) {\n  var state = _ref4.state,\n      config = _ref4.config,\n      stateKey = _ref4.stateKey,\n      args = _ref4.args;\n  var offset = state.offset;\n  var startTime = event.timeStamp;\n  var initial = config.initial,\n      bounds = config.bounds;\n\n  var _state = _extends({}, getInitialState()[stateKey], {\n    _active: true,\n    args: args,\n    values: values,\n    initial: values,\n    offset: offset,\n    lastOffset: offset,\n    startTime: startTime\n  });\n\n  return _extends({}, _state, {\n    _initial: valueFn(initial, _state),\n    _bounds: valueFn(bounds, _state)\n  });\n}\n/**\r\n * The controller will keep track of the state for all gestures and also keep\r\n * track of timeouts, and window listeners.\r\n */\n\n\nvar Controller = function Controller(classes) {\n  var _this = this;\n\n  this.classes = classes;\n  this.pointerIds = new Set(); // register Pointer Events pointerIds\n\n  this.touchIds = new Set(); // register Touch Events identifiers\n\n  this.supportsTouchEvents = supportsTouchEvents();\n  this.supportsGestureEvents = supportsGestureEvents();\n\n  this.bind = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var bindings = {};\n\n    for (var _iterator = _createForOfIteratorHelperLoose(_this.classes), _step; !(_step = _iterator()).done;) {\n      var RecognizerClass = _step.value;\n      new RecognizerClass(_this, args).addBindings(bindings);\n    } // // we also add event bindings for native handlers\n\n\n    var _loop = function _loop(eventKey) {\n      addBindings(bindings, eventKey, function (event) {\n        return _this.nativeRefs[eventKey](_extends({}, _this.state.shared, {\n          event: event,\n          args: args\n        }));\n      });\n    };\n\n    for (var eventKey in _this.nativeRefs) {\n      _loop(eventKey);\n    }\n\n    if (_this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(_this, bindings);\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(_this, bindings);\n    }\n  };\n\n  this.effect = function () {\n    if (_this.config.domTarget) _this.bind();\n    return _this.clean;\n  };\n  /**\r\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\r\n   */\n\n\n  this.clean = function () {\n    var domTarget = getDomTargetFromConfig(_this.config);\n    var eventOptions = _this.config.eventOptions;\n    if (domTarget) removeListeners(domTarget, takeAll(_this.domListeners), eventOptions);\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    clearAllWindowListeners(_this);\n  };\n\n  this.classes = classes;\n  this.state = getInitialState();\n  this.timeouts = {};\n  this.domListeners = [];\n  this.windowListeners = {};\n};\n\nfunction addEventIds(controller, event) {\n  if ('pointerId' in event) {\n    controller.pointerIds.add(event.pointerId);\n  } else {\n    controller.touchIds = new Set(getTouchIds(event));\n  }\n}\n\nfunction removeEventIds(controller, event) {\n  if ('pointerId' in event) {\n    controller.pointerIds[\"delete\"](event.pointerId);\n  } else {\n    getTouchIds(event).forEach(function (id) {\n      return controller.touchIds[\"delete\"](id);\n    });\n  }\n}\n\nfunction clearAllWindowListeners(controller) {\n  var _controller$config = controller.config,\n      el = _controller$config.window,\n      eventOptions = _controller$config.eventOptions,\n      windowListeners = controller.windowListeners;\n  if (!el) return;\n\n  for (var stateKey in windowListeners) {\n    var handlers = windowListeners[stateKey];\n    removeListeners(el, handlers, eventOptions);\n  }\n\n  controller.windowListeners = {};\n}\n\nfunction clearWindowListeners(_ref, stateKey, options) {\n  var config = _ref.config,\n      windowListeners = _ref.windowListeners;\n\n  if (options === void 0) {\n    options = config.eventOptions;\n  }\n\n  if (!config.window) return;\n  removeListeners(config.window, windowListeners[stateKey], options);\n  delete windowListeners[stateKey];\n}\n\nfunction updateWindowListeners(_ref2, stateKey, listeners, options) {\n  var config = _ref2.config,\n      windowListeners = _ref2.windowListeners;\n\n  if (listeners === void 0) {\n    listeners = [];\n  }\n\n  if (options === void 0) {\n    options = config.eventOptions;\n  }\n\n  if (!config.window) return;\n  removeListeners(config.window, windowListeners[stateKey], options);\n  addListeners(config.window, windowListeners[stateKey] = listeners, options);\n}\n\nfunction updateDomListeners(_ref3, bindings) {\n  var config = _ref3.config,\n      domListeners = _ref3.domListeners;\n  var domTarget = getDomTargetFromConfig(config);\n  if (!domTarget) throw new Error('domTarget must be defined');\n  var eventOptions = config.eventOptions;\n  removeListeners(domTarget, takeAll(domListeners), eventOptions);\n\n  for (var _i = 0, _Object$entries = Object.entries(bindings); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _Object$entries[_i],\n        key = _Object$entries$_i[0],\n        fns = _Object$entries$_i[1];\n    var name = key.slice(2).toLowerCase();\n    domListeners.push([name, chainFns.apply(void 0, fns)]);\n  }\n\n  addListeners(domTarget, domListeners, eventOptions);\n}\n\nfunction getPropsListener(_ref4, bindings) {\n  var config = _ref4.config;\n  var props = {};\n  var captureString = config.eventOptions.capture ? 'Capture' : '';\n\n  for (var _i2 = 0, _Object$entries2 = Object.entries(bindings); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _Object$entries2[_i2],\n        event = _Object$entries2$_i[0],\n        fns = _Object$entries2$_i[1];\n    var fnsArray = Array.isArray(fns) ? fns : [fns];\n    var key = event + captureString;\n    props[key] = chainFns.apply(void 0, fnsArray);\n  }\n\n  return props;\n}\n\nfunction takeAll(array) {\n  if (array === void 0) {\n    array = [];\n  }\n\n  return array.splice(0, array.length);\n}\n\nfunction getDomTargetFromConfig(_ref5) {\n  var domTarget = _ref5.domTarget;\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n}\n/**\r\n * bindings is an object which keys match ReactEventHandlerKeys.\r\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n * that key.\r\n */\n\n\nfunction addBindings(bindings, name, fn) {\n  if (!bindings[name]) bindings[name] = [];\n  bindings[name].push(fn);\n}\n\nfunction addListeners(el, listeners, options) {\n  if (listeners === void 0) {\n    listeners = [];\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(listeners), _step2; !(_step2 = _iterator2()).done;) {\n    var _step2$value = _step2.value,\n        eventName = _step2$value[0],\n        eventHandler = _step2$value[1];\n    el.addEventListener(eventName, eventHandler, options);\n  }\n}\n\nfunction removeListeners(el, listeners, options) {\n  if (listeners === void 0) {\n    listeners = [];\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  for (var _iterator3 = _createForOfIteratorHelperLoose(listeners), _step3; !(_step3 = _iterator3()).done;) {\n    var _step3$value = _step3.value,\n        eventName = _step3$value[0],\n        eventHandler = _step3$value[1];\n    el.removeEventListener(eventName, eventHandler, options);\n  }\n}\n/* eslint-disable react-hooks/exhaustive-deps */\n\n/**\r\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\r\n *\r\n * @param handlers\r\n * @param classes\r\n * @param config\r\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\r\n */\n\n\nfunction useRecognizers(handlers, config, nativeHandlers) {\n  if (nativeHandlers === void 0) {\n    nativeHandlers = {};\n  }\n\n  var classes = resolveClasses(handlers);\n  var controller = React.useMemo(function () {\n    return new Controller(classes);\n  }, []);\n  controller.config = config;\n  controller.handlers = handlers;\n  controller.nativeRefs = nativeHandlers;\n  React.useEffect(controller.effect, []); // @ts-ignore\n\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget; // @ts-ignore\n\n  return controller.bind;\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-console\n    console.warn(\"Deprecation notice: When the `domTarget` option is specified, you don't need to write `useEffect(bind, [bind])` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when `domTarget` is provided, therefore your code will break if you try to call `useEffect`.\");\n  }\n}\n\nfunction resolveClasses(internalHandlers) {\n  var classes = new Set();\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag'));\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel'));\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll'));\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move'));\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch'));\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover'));\n  return classes;\n}\n/**\r\n * @private\r\n * Abstract class for coordinates-based gesture recongizers\r\n */\n\n\nvar CoordinatesRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n\n  function CoordinatesRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = CoordinatesRecognizer.prototype;\n  /**\r\n   * Returns the real movement (without taking intentionality into account)\r\n   */\n\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    return subV(values, state.initial);\n  }\n  /**\r\n   * In coordinates-based gesture, this function will detect the first intentional axis,\r\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\r\n   * if the first intentional axis doesn't match the specified axis in config.\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return {\n        _intentional: _intentional,\n        axis: this.state.axis\n      };\n    }\n\n    var _movement$map = _movement.map(Math.abs),\n        absX = _movement$map[0],\n        absY = _movement$map[1];\n\n    var axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined);\n    if (!this.config.axis && !this.config.lockDirection) return {\n      _intentional: _intentional,\n      _blocked: false,\n      axis: axis\n    };\n    if (!axis) return {\n      _intentional: [false, false],\n      _blocked: false,\n      axis: axis\n    };\n    if (!!this.config.axis && axis !== this.config.axis) return {\n      _intentional: _intentional,\n      _blocked: true,\n      axis: axis\n    };\n    _intentional[axis === 'x' ? 1 : 0] = false;\n    return {\n      _intentional: _intentional,\n      _blocked: false,\n      axis: axis\n    };\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var state = this.getMovement(values);\n\n    if (!state._blocked) {\n      var dt = event.timeStamp - this.state.timeStamp;\n      Object.assign(state, calculateAllKinematics(state.movement, state.delta, dt));\n    }\n\n    return state;\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      xy: state.values,\n      vxvy: state.velocities\n    };\n  };\n\n  return CoordinatesRecognizer;\n}(Recognizer);\n\nvar TAP_DISTANCE_THRESHOLD = 3;\n\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nvar DragRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n\n  function DragRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'dragging';\n    _this.stateKey = 'drag'; // TODO add back when setPointerCapture is widely wupported\n    // https://caniuse.com/#search=setPointerCapture\n\n    _this.setPointerCapture = function (event) {\n      // don't perform pointere capture when user wants to use touch events or\n      // when a pointerLockElement exists as this would throw an error\n      if (_this.config.useTouch || document.pointerLockElement) return;\n      var target = event.target,\n          pointerId = event.pointerId;\n\n      if (target && 'setPointerCapture' in target) {\n        // this would work in the DOM but doesn't with react three fiber\n        // target.addEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n        // @ts-expect-error\n        target.setPointerCapture(pointerId);\n      }\n\n      _this.updateGestureState({\n        _dragTarget: target,\n        _dragPointerId: pointerId\n      });\n    };\n\n    _this.releasePointerCapture = function () {\n      if (_this.config.useTouch || document.pointerLockElement) return;\n      var _this$state = _this.state,\n          _dragTarget = _this$state._dragTarget,\n          _dragPointerId = _this$state._dragPointerId;\n\n      if (_dragPointerId && _dragTarget && 'releasePointerCapture' in _dragTarget) {\n        // this would work in the DOM but doesn't with react three fiber\n        // target.removeEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n        if (!('hasPointerCapture' in _dragTarget) || _dragTarget.hasPointerCapture(_dragPointerId)) try {\n          _dragTarget.releasePointerCapture(_dragPointerId);\n        } catch (e) {}\n      }\n    };\n\n    _this.preventScroll = function (event) {\n      if (_this.state._dragPreventScroll && event.cancelable) {\n        event.preventDefault();\n      }\n    };\n\n    _this.getEventId = function (event) {\n      if (_this.config.useTouch) return event.changedTouches[0].identifier;\n      return event.pointerId;\n    };\n\n    _this.isValidEvent = function (event) {\n      // if we were using pointer events only event.isPrimary === 1 would suffice\n      return _this.state._pointerId === _this.getEventId(event);\n    };\n\n    _this.shouldPreventWindowScrollY = _this.config.experimental_preventWindowScrollY && _this.controller.supportsTouchEvents;\n\n    _this.setUpWindowScrollDetection = function (event) {\n      persistEvent(event); // we add window listeners that will prevent the scroll when the user has started dragging\n\n      updateWindowListeners(_this.controller, _this.stateKey, [['touchmove', _this.preventScroll], ['touchend', _this.clean.bind(_assertThisInitialized(_this))], ['touchcancel', _this.clean.bind(_assertThisInitialized(_this))]], {\n        passive: false\n      });\n\n      _this.setTimeout(_this.startDrag.bind(_assertThisInitialized(_this)), 250, event);\n    };\n\n    _this.setUpDelayedDragTrigger = function (event) {\n      _this.state._dragDelayed = true;\n      persistEvent(event);\n\n      _this.setTimeout(_this.startDrag.bind(_assertThisInitialized(_this)), _this.config.delay, event);\n    };\n\n    _this.setStartState = function (event) {\n      var values = getPointerEventValues(event, _this.transform);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        _pointerId: _this.getEventId(event)\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n    };\n\n    _this.onDragStart = function (event) {\n      addEventIds(_this.controller, event);\n      if (!_this.enabled || _this.state._active) return;\n\n      _this.setStartState(event);\n\n      _this.setPointerCapture(event);\n\n      if (_this.shouldPreventWindowScrollY) _this.setUpWindowScrollDetection(event);else if (_this.config.delay > 0) _this.setUpDelayedDragTrigger(event);else _this.startDrag(event, true); // we pass the values to the startDrag event\n    };\n\n    _this.onDragChange = function (event) {\n      if ( // if the gesture was canceled or\n      _this.state.canceled || // if onDragStart wasn't fired or\n      !_this.state._active || // if the event pointerId doesn't match the one that initiated the drag\n      !_this.isValidEvent(event) || // if the event has the same timestamp as the previous event\n      // note that checking type equality is ONLY for tests \\_()_/\n      _this.state._lastEventType === event.type && event.timeStamp === _this.state.timeStamp) return;\n      var values;\n\n      if (document.pointerLockElement) {\n        var movementX = event.movementX,\n            movementY = event.movementY;\n        values = addV(_this.transform([movementX, movementY]), _this.state.values);\n      } else values = getPointerEventValues(event, _this.transform);\n\n      var kinematics = _this.getKinematics(values, event); // if startDrag hasn't fired\n\n\n      if (!_this.state._dragStarted) {\n        // If the gesture isn't active then respond to the event only if\n        // it's been delayed via the `delay` option, in which case start\n        // the gesture immediately.\n        if (_this.state._dragDelayed) {\n          _this.startDrag(event);\n\n          return;\n        } // if the user wants to prevent vertical window scroll when user starts dragging\n\n\n        if (_this.shouldPreventWindowScrollY) {\n          if (!_this.state._dragPreventScroll && kinematics.axis) {\n            // if the user is dragging horizontally then we should allow the drag\n            if (kinematics.axis === 'x') {\n              _this.startDrag(event);\n            } else {\n              _this.state._active = false;\n              return;\n            }\n          } else return;\n        } else return;\n      }\n\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var genericPayload = getGenericPayload(_assertThisInitialized(_this), event); // This verifies if the drag can be assimilated to a tap by checking\n      // if the real distance of the drag (ie not accounting for the threshold) is\n      // greater than the TAP_DISTANCE_THRESHOLD.\n\n      var realDistance = calculateDistance(kinematics._movement);\n      var _dragIsTap = _this.state._dragIsTap;\n      if (_dragIsTap && realDistance >= TAP_DISTANCE_THRESHOLD) _dragIsTap = false;\n\n      _this.updateGestureState(_extends({}, genericPayload, kinematics, {\n        _dragIsTap: _dragIsTap\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onDragEnd = function (event) {\n      removeEventIds(_this.controller, event); // if the event pointerId doesn't match the one that initiated the drag\n      // we don't want to end the drag\n\n      if (!_this.isValidEvent(event)) return;\n\n      _this.clean(); // if the gesture is no longer active (ie canceled)\n      // don't do anything\n\n\n      if (!_this.state._active) return;\n      _this.state._active = false;\n      var tap = _this.state._dragIsTap;\n      var _this$state$velocitie = _this.state.velocities,\n          vx = _this$state$velocitie[0],\n          vy = _this$state$velocitie[1];\n      var _this$state$movement = _this.state.movement,\n          mx = _this$state$movement[0],\n          my = _this$state$movement[1];\n      var _this$state$_intentio = _this.state._intentional,\n          ix = _this$state$_intentio[0],\n          iy = _this$state$_intentio[1];\n      var _this$config$swipeVel = _this.config.swipeVelocity,\n          svx = _this$config$swipeVel[0],\n          svy = _this$config$swipeVel[1];\n      var _this$config$swipeDis = _this.config.swipeDistance,\n          sx = _this$config$swipeDis[0],\n          sy = _this$config$swipeDis[1];\n      var sd = _this.config.swipeDuration;\n\n      var endState = _extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values));\n\n      var swipe = [0, 0];\n\n      if (endState.elapsedTime < sd) {\n        if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx);\n        if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy);\n      }\n\n      _this.updateSharedState({\n        buttons: 0\n      });\n\n      _this.updateGestureState(_extends({}, endState, {\n        tap: tap,\n        swipe: swipe\n      }));\n\n      _this.fireGestureHandler(_this.config.filterTaps && tap === true);\n    };\n\n    _this.clean = function () {\n      _CoordinatesRecognize.prototype.clean.call(_assertThisInitialized(_this));\n\n      _this.state._dragStarted = false;\n\n      _this.releasePointerCapture();\n\n      clearWindowListeners(_this.controller, _this.stateKey);\n    };\n\n    _this.onCancel = function () {\n      if (_this.state.canceled) return;\n\n      _this.updateGestureState({\n        canceled: true,\n        _active: false\n      });\n\n      _this.updateSharedState({\n        buttons: 0\n      });\n\n      setTimeout(function () {\n        return _this.fireGestureHandler();\n      }, 0);\n    };\n\n    _this.onClick = function (event) {\n      if (!_this.state._dragIsTap) event.stopPropagation();\n    };\n\n    return _this;\n  }\n\n  var _proto = DragRecognizer.prototype;\n\n  _proto.startDrag = function startDrag(event, onDragIsStart) {\n    if (onDragIsStart === void 0) {\n      onDragIsStart = false;\n    } // startDrag can happen after a timeout, so we need to check if the gesture is still active\n    // as the user might have lift up the pointer in between.\n\n\n    if ( // if the gesture isn't active (probably means)\n    !this.state._active || // if the drag has already started we should ignore subsequent attempts\n    this.state._dragStarted) return;\n    if (!onDragIsStart) this.setStartState(event);\n    this.updateGestureState({\n      _dragStarted: true,\n      _dragPreventScroll: true,\n      cancel: this.onCancel\n    });\n    this.clearTimeout();\n    this.fireGestureHandler();\n  };\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    if (this.config.useTouch) {\n      addBindings(bindings, 'onTouchStart', this.onDragStart);\n      addBindings(bindings, 'onTouchMove', this.onDragChange); // this is needed for react-three-fiber\n\n      addBindings(bindings, 'onTouchEnd', this.onDragEnd);\n      addBindings(bindings, 'onTouchCancel', this.onDragEnd);\n    } else {\n      addBindings(bindings, 'onPointerDown', this.onDragStart);\n      addBindings(bindings, 'onPointerMove', this.onDragChange); // this is needed for react-three-fiber\n\n      addBindings(bindings, 'onPointerUp', this.onDragEnd);\n      addBindings(bindings, 'onPointerCancel', this.onDragEnd);\n    }\n\n    if (this.config.filterTaps) {\n      var handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture';\n      addBindings(bindings, handler, this.onClick);\n    }\n  };\n\n  return DragRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Inlined from https://github.com/alexreardon/memoize-one\r\n */\n\n\nfunction memoizeOne(resultFn, isEqual) {\n  var lastThis;\n  var lastArgs = [];\n  var lastResult;\n  var calledOnce = false;\n\n  function memoized() {\n    for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      newArgs[_key] = arguments[_key];\n    }\n\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult;\n    }\n\n    lastResult = resultFn.apply(this, newArgs);\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    return lastResult;\n  }\n\n  return memoized;\n}\n/**\r\n * Taken from https://github.com/FormidableLabs/react-fast-compare\r\n *\r\n * Dropped comments and ArrayBuffer handling\r\n */\n\n\nfunction equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length, i, keys;\n\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!equal(a[i], b[i])) return false;\n      }\n\n      return true;\n    }\n\n    var it;\n\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n\n      while (!(i = it.next()).done) {\n        if (!b.has(i.value[0])) return false;\n      }\n\n      it = a.entries();\n\n      while (!(i = it.next()).done) {\n        if (!equal(i.value[1], b.get(i.value[0]))) return false;\n      }\n\n      return true;\n    }\n\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n\n      while (!(i = it.next()).done) {\n        if (!b.has(i.value[0])) return false;\n      }\n\n      return true;\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    if (typeof Element !== 'undefined' && a instanceof Element) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (keys[i] === '_owner' && a.$$typeof) continue;\n      if (!equal(a[keys[i]], b[keys[i]])) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise  NaN !== NaN  true\n  // eslint-disable-next-line no-self-compare\n\n\n  return a !== a && b !== b;\n}\n\nfunction isEqual(a, b) {\n  try {\n    return equal(a, b);\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      // eslint-disable-next-line no-console\n      console.warn('react-fast-compare cannot handle circular refs');\n      return false;\n    }\n\n    throw error;\n  }\n}\n/**\r\n * Drag hook.\r\n *\r\n * @param handler - the function fired every time the drag gesture updates\r\n * @param [config={}] - the config object including generic options and drag options\r\n */\n\n\nfunction useDrag(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('drag', DragRecognizer);\n  var buildDragConfig = useRef();\n\n  if (!buildDragConfig.current) {\n    buildDragConfig.current = memoizeOne(_buildDragConfig, isEqual);\n  }\n\n  return useRecognizers({\n    drag: handler\n  }, buildDragConfig.current(config));\n}\n/**\r\n * @private\r\n * Abstract class for distance/angle-based gesture recongizers\r\n */\n\n\nvar DistanceAngleRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n\n  function DistanceAngleRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = DistanceAngleRecognizer.prototype;\n\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    var prev_a = state.values[1]; // not be defined if ctrl+wheel is used for zoom only\n\n    var d = values[0],\n        _values$ = values[1],\n        a = _values$ === void 0 ? prev_a : _values$;\n    var delta_a = a - prev_a;\n    var next_turns = state.turns;\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a);\n    return subV([d, a - 360 * next_turns], state.initial);\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var state = this.getMovement(values);\n    var turns = (values[1] - state._movement[1] - this.state.initial[1]) / 360;\n    var dt = event.timeStamp - this.state.timeStamp;\n\n    var _calculateAllKinemati = calculateAllKinematics(state.movement, state.delta, dt),\n        kinematics = _objectWithoutPropertiesLoose(_calculateAllKinemati, [\"distance\", \"velocity\"]);\n\n    return _extends({\n      turns: turns\n    }, state, kinematics);\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      da: state.values,\n      vdva: state.velocities\n    };\n  };\n\n  return DistanceAngleRecognizer;\n}(Recognizer);\n\nvar ZOOM_CONSTANT = 7;\nvar WEBKIT_DISTANCE_SCALE_FACTOR = 260;\n\nvar PinchRecognizer = /*#__PURE__*/function (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n\n  function PinchRecognizer() {\n    var _this;\n\n    _this = _DistanceAngleRecogni.apply(this, arguments) || this;\n    _this.ingKey = 'pinching';\n    _this.stateKey = 'pinch';\n\n    _this.onPinchStart = function (event) {\n      addEventIds(_this.controller, event);\n      var touchIds = _this.controller.touchIds;\n      if (!_this.enabled) return;\n\n      if (_this.state._active) {\n        // check that the pointerIds that initiated the gesture\n        // are still enabled. This is useful for when the page\n        // loses track of the pointers (minifying gesture on iPad).\n        if (_this.state._pointerIds.every(function (id) {\n          return touchIds.has(id);\n        })) return; // something was wrong with the pointers but we let it go.\n      } // until we reach two fingers on the target don't react\n\n\n      if (touchIds.size < 2) return;\n\n      var _pointerIds = Array.from(touchIds).slice(0, 2);\n\n      var _getTwoTouchesEventVa = getTwoTouchesEventValues(event, _pointerIds, _this.transform),\n          values = _getTwoTouchesEventVa.values,\n          origin = _getTwoTouchesEventVa.origin;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        _pointerIds: _pointerIds,\n        cancel: _this.onCancel,\n        origin: origin\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n          canceled = _this$state.canceled,\n          _active = _this$state._active;\n      if (canceled || !_active || // if the event has the same timestamp as the previous event\n      event.timeStamp === _this.state.timeStamp) return;\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      try {\n        var _getTwoTouchesEventVa2 = getTwoTouchesEventValues(event, _this.state._pointerIds, _this.transform),\n            values = _getTwoTouchesEventVa2.values,\n            origin = _getTwoTouchesEventVa2.origin;\n\n        var kinematics = _this.getKinematics(values, event);\n\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n          origin: origin\n        }));\n\n        _this.fireGestureHandler();\n      } catch (e) {\n        _this.onPinchEnd(event);\n      }\n    };\n\n    _this.onPinchEnd = function (event) {\n      removeEventIds(_this.controller, event);\n      var pointerIds = getTouchIds(event); // if none of the lifted pointerIds is in the state pointerIds don't do anything\n\n      if (_this.state._pointerIds.every(function (id) {\n        return !pointerIds.includes(id);\n      })) return;\n\n      _this.clean();\n\n      if (!_this.state._active) return;\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values), {\n        _active: false\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onCancel = function () {\n      if (_this.state.canceled) return;\n\n      _this.updateGestureState({\n        _active: false,\n        canceled: true\n      });\n\n      setTimeout(function () {\n        return _this.fireGestureHandler();\n      }, 0);\n    };\n    /**\r\n     * PINCH WITH WEBKIT GESTURES\r\n     */\n\n\n    _this.onGestureStart = function (event) {\n      if (!_this.enabled) return;\n      event.preventDefault(); // useless\n\n      var values = getWebkitGestureEventValues(event, _this.transform);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        origin: [event.clientX, event.clientY],\n        cancel: _this.onCancel\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureChange = function (event) {\n      var _this$state2 = _this.state,\n          canceled = _this$state2.canceled,\n          _active = _this$state2._active;\n      if (canceled || !_active) return;\n      event.preventDefault();\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData); // this normalizes the values of the Safari's WebkitEvent by calculating\n      // the delta and then multiplying it by a constant.\n\n\n      var values = getWebkitGestureEventValues(event, _this.transform);\n      values[0] = (values[0] - _this.state.event.scale) * WEBKIT_DISTANCE_SCALE_FACTOR + _this.state.values[0];\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n        origin: [event.clientX, event.clientY]\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureEnd = function (event) {\n      _this.clean();\n\n      if (!_this.state._active) return;\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values), {\n        _active: false,\n        origin: [event.clientX, event.clientY]\n      }));\n\n      _this.fireGestureHandler();\n    };\n    /**\r\n     * PINCH WITH WHEEL\r\n     */\n\n\n    _this.wheelShouldRun = function (event) {\n      return _this.enabled && event.ctrlKey;\n    };\n\n    _this.getWheelValuesFromEvent = function (event) {\n      var _getWheelEventValues = getWheelEventValues(event, _this.transform),\n          delta_d = _getWheelEventValues[1];\n\n      var _this$state$values = _this.state.values,\n          prev_d = _this$state$values[0],\n          prev_a = _this$state$values[1]; // ZOOM_CONSTANT is based on Safari trackpad natural zooming\n\n      var d = prev_d - delta_d * ZOOM_CONSTANT;\n      var a = prev_a !== void 0 ? prev_a : 0;\n      return {\n        values: [d, a],\n        origin: [event.clientX, event.clientY],\n        delta: [0, delta_d]\n      };\n    };\n\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n\n      _this.setTimeout(_this.onWheelEnd);\n\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n\n    _this.onWheelStart = function (event) {\n      var _this$getWheelValuesF = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF.values,\n          delta = _this$getWheelValuesF.delta,\n          origin = _this$getWheelValuesF.origin;\n\n      if (event.cancelable) event.preventDefault();else if (process.env.NODE_ENV === 'development') {\n        // eslint-disable-next-line no-console\n        console.warn('To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.');\n      }\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        initial: _this.state.values,\n        offset: values,\n        delta: delta,\n        origin: origin\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelChange = function (event) {\n      if (event.cancelable) event.preventDefault();\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var _this$getWheelValuesF2 = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF2.values,\n          origin = _this$getWheelValuesF2.origin,\n          delta = _this$getWheelValuesF2.delta;\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event), {\n        origin: origin,\n        delta: delta\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelEnd = function () {\n      _this.clean();\n\n      if (!_this.state._active) return;\n      _this.state._active = false;\n\n      _this.updateGestureState(_this.getMovement(_this.state.values));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && !this.controller.supportsTouchEvents && this.controller.supportsGestureEvents) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart);\n      addBindings(bindings, 'onGestureChange', this.onGestureChange);\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd);\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart);\n      addBindings(bindings, 'onTouchMove', this.onPinchChange);\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd);\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd);\n      addBindings(bindings, 'onWheel', this.onWheel);\n    }\n  };\n\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n/**\r\n * Pinch hook.\r\n *\r\n * @param handler - the function fired every time the pinch gesture updates\r\n * @param [config={}] - the config object including generic options and pinch options\r\n */\n\n\nfunction usePinch(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('pinch', PinchRecognizer);\n  var buildPinchConfig = useRef();\n\n  if (!buildPinchConfig.current) {\n    buildPinchConfig.current = memoizeOne(_buildPinchConfig, isEqual);\n  }\n\n  return useRecognizers({\n    pinch: handler\n  }, buildPinchConfig.current(config));\n}\n\nvar WheelRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n\n  function WheelRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'wheeling';\n    _this.stateKey = 'wheel';\n    _this.debounced = true;\n\n    _this.handleEvent = function (event) {\n      if (event.ctrlKey && 'pinch' in _this.controller.handlers) return;\n      if (!_this.enabled) return;\n\n      _this.setTimeout(_this.onEnd);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var values = addV(getWheelEventValues(event, _this.transform), _this.state.values);\n\n      if (!_this.state._active) {\n        _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n          initial: _this.state.values\n        }));\n\n        var movement = _this.getMovement(values);\n\n        var geometry = calculateAllGeometry(movement.delta);\n\n        _this.updateGestureState(movement);\n\n        _this.updateGestureState(geometry);\n      } else {\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      }\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onEnd = function () {\n      _this.clean();\n\n      if (!_this.state._active) return;\n\n      var movement = _this.getMovement(_this.state.values);\n\n      _this.updateGestureState(movement);\n\n      _this.updateGestureState({\n        _active: false,\n        velocities: [0, 0],\n        velocity: 0\n      });\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = WheelRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onWheel', this.handleEvent);\n  };\n\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Wheel hook.\r\n *\r\n * @param handler - the function fired every time the wheel gesture updates\r\n * @param the config object including generic options and wheel options\r\n */\n\n\nfunction useWheel(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('wheel', WheelRecognizer);\n  var buildWheelConfig = useRef();\n\n  if (!buildWheelConfig.current) {\n    buildWheelConfig.current = memoizeOne(_buildWheelConfig, isEqual);\n  }\n\n  return useRecognizers({\n    wheel: handler\n  }, buildWheelConfig.current(config));\n}\n\nvar MoveRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n\n  function MoveRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'moving';\n    _this.stateKey = 'move';\n    _this.debounced = true;\n\n    _this.onMove = function (event) {\n      if (!_this.enabled) return;\n\n      _this.setTimeout(_this.onMoveEnd);\n\n      if (!_this.state._active) _this.onMoveStart(event);else _this.onMoveChange(event);\n    };\n\n    _this.onMoveStart = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n\n      var values = getPointerEventValues(event, _this.transform);\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true)));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveChange = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n\n      var values = getPointerEventValues(event, _this.transform);\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveEnd = function () {\n      _this.clean();\n\n      if (!_this.state._active) return;\n      var values = _this.state.values;\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.updateGestureState({\n        velocities: [0, 0],\n        velocity: 0,\n        _active: false\n      });\n\n      _this.fireGestureHandler();\n    };\n\n    _this.hoverTransform = function () {\n      return _this.controller.config.hover.transform || _this.controller.config.transform;\n    };\n\n    _this.onPointerEnter = function (event) {\n      _this.controller.state.shared.hovering = true;\n      if (!_this.controller.config.enabled) return;\n\n      if (_this.controller.config.hover.enabled) {\n        var values = getPointerEventValues(event, _this.hoverTransform());\n\n        var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event, true), {\n          args: _this.args,\n          values: values,\n          active: true,\n          hovering: true\n        });\n\n        _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n      }\n\n      if ('move' in _this.controller.handlers) _this.onMoveStart(event);\n    };\n\n    _this.onPointerLeave = function (event) {\n      _this.controller.state.shared.hovering = false;\n      if ('move' in _this.controller.handlers) _this.onMoveEnd();\n      if (!_this.controller.config.hover.enabled) return;\n      var values = getPointerEventValues(event, _this.hoverTransform());\n\n      var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event), {\n        args: _this.args,\n        values: values,\n        active: false\n      });\n\n      _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n    };\n\n    return _this;\n  }\n\n  var _proto = MoveRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove);\n    }\n\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter);\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave);\n    }\n  };\n\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Move hook.\r\n *\r\n * @param handler - the function fired every time the move gesture updates\r\n * @param [config={}] - the config object including generic options and move options\r\n */\n\n\nfunction useMove(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('move', MoveRecognizer);\n  var buildMoveConfig = useRef();\n\n  if (!buildMoveConfig.current) {\n    buildMoveConfig.current = memoizeOne(_buildMoveConfig, isEqual);\n  }\n\n  return useRecognizers({\n    move: handler\n  }, buildMoveConfig.current(config));\n}\n/**\r\n * Hover hook.\r\n *\r\n * @param handler - the function fired every time the hover gesture updates\r\n * @param [config={}] - the config object including generic options and hover options\r\n */\n\n\nfunction useHover(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('hover', MoveRecognizer);\n  var buildHoverConfig = useRef();\n\n  if (!buildHoverConfig.current) {\n    buildHoverConfig.current = memoizeOne(_buildHoverConfig, isEqual);\n  }\n\n  return useRecognizers({\n    hover: handler\n  }, buildHoverConfig.current(config));\n}\n\nvar ScrollRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n\n  function ScrollRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'scrolling';\n    _this.stateKey = 'scroll';\n    _this.debounced = true;\n\n    _this.handleEvent = function (event) {\n      if (!_this.enabled) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      var values = getScrollEventValues(event, _this.transform);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      if (!_this.state._active) {\n        _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n          initial: _this.state.values\n        }));\n\n        var movementDetection = _this.getMovement(values);\n\n        var geometry = calculateAllGeometry(movementDetection.delta);\n\n        _this.updateGestureState(movementDetection);\n\n        _this.updateGestureState(geometry);\n      } else {\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      }\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onEnd = function () {\n      _this.clean();\n\n      if (!_this.state._active) return;\n\n      _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n        _active: false,\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = ScrollRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onScroll', this.handleEvent);\n  };\n\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Scroll hook.\r\n *\r\n * @param handler - the function fired every time the scroll gesture updates\r\n * @param [config={}] - the config object including generic options and scroll options\r\n */\n\n\nfunction useScroll(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('scroll', ScrollRecognizer);\n  var buildScrollConfig = useRef();\n\n  if (!buildScrollConfig.current) {\n    buildScrollConfig.current = memoizeOne(_buildScrollConfig, isEqual);\n  }\n\n  return useRecognizers({\n    scroll: handler\n  }, buildScrollConfig.current(config));\n}\n\nvar RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\n\nfunction sortHandlers(handlers) {\n  var _native = {};\n  var handle = {};\n  var actions = new Set();\n\n  for (var key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handle[key] = handlers[key];\n    } else {\n      _native[key] = handlers[key];\n    }\n  }\n\n  return [handle, _native, actions];\n}\n/**\r\n * @public\r\n *\r\n * The most complete gesture hook, allowing support for multiple gestures.\r\n *\r\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\r\n * @param {UseGestureConfig} [config={}] - the full config object\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useGesture(_handlers, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _sortHandlers = sortHandlers(_handlers),\n      handlers = _sortHandlers[0],\n      nativeHandlers = _sortHandlers[1],\n      actions = _sortHandlers[2];\n\n  RecognizersMap.set('drag', DragRecognizer);\n  RecognizersMap.set('hover', MoveRecognizer);\n  RecognizersMap.set('move', MoveRecognizer);\n  RecognizersMap.set('pinch', PinchRecognizer);\n  RecognizersMap.set('scroll', ScrollRecognizer);\n  RecognizersMap.set('wheel', WheelRecognizer);\n  var mergedConfig = buildComplexConfig(config, actions);\n  var internalHandlers = {};\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag');\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel');\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll');\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove');\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch');\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover;\n  return useRecognizers(internalHandlers, mergedConfig, nativeHandlers);\n}\n\nfunction includeStartEndHandlers(handlers, handlerKey) {\n  var startKey = handlerKey + 'Start';\n  var endKey = handlerKey + 'End';\n\n  var fn = function fn(state) {\n    var memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  return fn;\n}\n\nexport { addV, rubberbandIfOutOfBounds, subV, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };","import React, {\n  FC,\n  ReactNode,\n  useState,\n} from 'react';\nimport { animated } from 'react-spring';\nimport { useDrag } from 'react-use-gesture';\n\ninterface IPosition {\n  start: number;\n  end: number;\n}\n\ninterface IProps {\n  width: number;\n  height: number;\n  brushWidth: number;\n  top?: number;\n  left?: number;\n  chart: () => ReactNode;\n  initialPosition?: IPosition;\n  onChange?: ({ start, end }: IPosition) => void;\n}\n\nconst Container: FC<{ width: number, height: number }> = ({\n  children,\n  height,\n  width,\n}) => <rect width={width}\n  height={height}\n  fill=\"#eee\"\n>{children}</rect>\n\n// @TODO resize handles...\nconst Brush: FC<IProps> = ({\n  onChange,\n  brushWidth,\n  width,\n  height,\n  top = 0,\n  left = 0,\n  chart,\n  initialPosition,\n}) => {\n  const start = initialPosition\n    ? { x: initialPosition.start, y: 0, w: brushWidth }\n    : { x: 0, y: 0, w: brushWidth };\n\n  const [{ x, y, w }, set] = useState(start);\n\n  // Set the drag hook and define component movement based on gesture data\n  const bounds = { top: 0, bottom: height, left: 0, right: width - w };\n\n  const bind = useDrag(({ movement: [mx, my] }) => {\n    onChange && onChange({ start: mx, end: mx + w })\n    set({ x: mx, y: 0, w })\n  },\n    {\n      initial: () => [x, y],\n      bounds,\n    });\n\n  const bindResizeLeft = useDrag((props) => {\n    const width = props._lastEventType === 'mousemove' ?\n      w - props.delta[0]\n      : w;\n    set({ x: props.movement[0], y, w: width });\n    onChange && onChange({ start: props.movement[0], end: y + width })\n  },\n    {\n\n      initial: () => [x, y],\n      bounds,\n    });\n\n  const bindResizeRight = useDrag((props) => {\n    const width = props._lastEventType === 'mousemove' ?\n      w + props.delta[0]\n      : w;\n    set({ x, y, w: width });\n    onChange && onChange({ start: x, end: y + width })\n  },\n    {\n\n      initial: () => [x, y],\n      bounds,\n    });\n\n  return (\n    <g transform={`translate(${left}, ${top})`}>\n      <Container width={width} height={height}>\n      </Container>\n      {chart()}\n\n      <animated.rect\n        width={w}\n        height={height}\n        fill=\"#aaeeff\"\n        {...bind()}\n        style={{\n          cursor: 'move',\n          opacity: 0.5,\n          x, y\n        } as any}\n      >\n\n      </animated.rect>\n      <animated.rect\n        {...bindResizeLeft()}\n        width={10} height={height}\n        style={{\n          x: x,\n          opacity: 0,\n          cursor: 'w-resize',\n          y,\n        } as any}\n      ></animated.rect>\n      <animated.rect\n        {...bindResizeRight()}\n        width={10} height={height}\n        style={{\n          x: x + w,\n          opacity: 0,\n          cursor: 'e-resize',\n          y,\n        } as any}\n      ></animated.rect>\n    </g >\n  )\n}\n\nexport default Brush;\n","// Be sure to include styles at some point, probably during your bootstrapping\nimport 'react-datasheet/lib/react-datasheet.css';\n\nimport { scaleTime } from 'd3-scale';\nimport React, {\n  FC,\n  useState,\n} from 'react';\n\nimport {\n  Card,\n  CardContent,\n  Grid,\n  Typography,\n} from '@material-ui/core';\n\nimport {\n  Base,\n  IAxes,\n  useWidth,\n} from '../../../src';\nimport Brush from '../../../src/components/Brush';\nimport Line from '../../../src/components/Line';\nimport { data3 } from '../../../test/fixtures';\nimport Layout from '../components/layout';\nimport SEO from '../components/seo';\n\nconst dateFormat = '%d-%b-%y';\n\nconst axis: IAxes = {\n  x: {\n    dateFormat,\n    scale: 'time',\n    width: 800,\n    height: 20,\n  },\n  y: {\n    label: 'TAB_VIEW_CREDITS',\n    numberFormat: 'd',\n    scale: 'log',\n    height: 200,\n    width: 20,\n  },\n};\n\nconst filterData = (scale: any, pos: { start: number, end: number }) => (data: any) => {\n  const x = scale(data.x);\n  return x >= pos.start && x <= pos.end;\n}\n\nconst { line, data } = data3[0];\n\nconst LineExample: FC = () => {\n  const [ref, width] = useWidth('90%');\n  const initialPosition = { start: 100, end: 200 };\n  const scale = scaleTime()\n    .domain([data[0].x, data[data.length - 1].x])\n    .range([0, width]);\n\n  const [brushedData, setBrushedData] = useState(data.filter(filterData(scale, initialPosition)));\n\n\n  const makeBrushedData = (pos: { start: number, end: number }) => {\n    setBrushedData(data.filter(filterData(scale, pos)));\n  }\n  return (\n    <Layout>\n      <SEO title=\"Brush for Line Chart\" description=\"\" />\n      <Typography variant=\"h2\">Brush</Typography>\n      <div>\n        <Grid container spacing={5} className=\"wrapper\">\n          <Grid item xs={12} md={6}>\n            <Card>\n              <CardContent ref={ref}>\n                <Base\n                  width={width}\n                  height={400}>\n\n                  <Line\n                    axis={axis}\n                    label=\"brushed data\"\n                    line={line}\n                    width={width}\n                    left={0}\n                    animate={false}\n                    height={200}\n                    data={brushedData} />\n\n                  <Brush width={width}\n                    top={250}\n                    initialPosition={initialPosition}\n                    brushWidth={100}\n                    chart={() => <Line\n                      axis={axis}\n                      label=\"brushed data\"\n                      line={line}\n                      width={width}\n                      left={0}\n                      height={50}\n                      data={data} />}\n                    onChange={(pos) => makeBrushedData(pos)}\n                    height={50} />\n                </Base>\n              </CardContent>\n            </Card>\n          </Grid>\n\n        </Grid>\n      </div>\n    </Layout>\n  );\n};\n\nexport default LineExample;\n","import {\n  curveCatmullRom,\n  curveStepBefore,\n} from 'd3-shape';\n\nimport {\n  IBarChartData,\n  ILineChartDataSet,\n} from '../src';\nimport { IHistogramData } from '../src/Histogram';\nimport { IChartPointValue } from '../src/LineChart';\nimport { IRadarChartData } from '../src/RadarChart';\nimport { IScatterPlotDataSet } from '../src/ScatterPlot';\nimport { ITornadoData } from '../src/Tornado';\n\nconst now = new Date();\nconst xs = new Array(100).fill('').map((_, i) => new Date(new Date().setDate(now.getDate() + i)))\nconst dateValues = xs.map((v, i) => ({\n  x: v, y: i * 1000,\n}));\n\nexport const lineChartData: ILineChartDataSet<any>[] = [\n  {\n    \"label\": \"cdd7c30f-4d9b-433c-a5d4-12bb39df89c6 usage\",\n    \"line\": {\n      \"fill\": {\n        \"fill\": \"rgba(11, 85, 167, 0.7)\",\n        \"show\": true\n      },\n      \"show\": true,\n      \"stroke\": \"#000\",\n      \"strokeDashArray\": \"0\",\n      \"strokeDashOffset\": 0,\n      curveType: curveStepBefore,\n    },\n    \"point\": {\n      \"fill\": \"#000\",\n      \"radius\": 2,\n      \"show\": true,\n      \"stroke\": \"#000\"\n    },\n    \"data\": dateValues\n  }\n]\n\nexport const histogramData: IHistogramData = {\n  bins: [[0, 50], [50, 150], [150, 300]],\n  counts: [\n    {\n      data: [500, 2000, 1500],\n      label: 'Baseline',\n    },\n  ]\n}\n\nexport const barChartData: IBarChartData = {\n  bins: ['Female', 'Male', 'Other', 'sdfdfg', 'dagdsg', 'sfsd', 'ds34fsdf', 'dfsfsd', 'sdfs34dfs', 'ghf34hfg', 'fd33gag', 'jg343hj', 'a343wes', 'ye343ye', 'fd343gjs', 'sdfd343fg', '34', 'sfsd', '433', '45245', '745'],\n  counts: [\n    {\n      data: [58483, 52400, 13300, 79200, 52400, 13300, 79200, 52400, 13300, 79200, 52400, 13300, 79200, 52400, 13300, 79200, 52400, 13300, 79200, 52400, 13300],\n      label: 'Baseline',\n    },\n    {\n      data: [54932, 34230, 10000, 60000, 34230, 10000, 60000, 34230, 10000, 60000, 34230, 10000, 60000, 34230, 10000, 60000, 34230, 10000, 60000, 34230, 10000],\n      label: 'Filtered',\n    },\n  ]\n}\n\nexport const data3: ILineChartDataSet<any>[] = [{\n  'label': 'rob Allocation',\n  'line': {\n    'curveType': curveCatmullRom,\n    fill: { fill: 'rgba(11, 85, 167, 0.2)', show: true },\n    show: true,\n    stroke: 'rgb(11, 85, 167)',\n    'strokeDashArray': '0',\n    'strokeDashOffset': 0\n  },\n  'point':\n    { fill: '#000', radius: 4, show: true, stroke: '' },\n  'data': dateValues,\n}, {\n  'label': 'rob\\'',\n  'line': {\n    'curveType': curveCatmullRom,\n    fill: { fill: 'rgba(11, 85, 167, 0.7)', show: true },\n    show: true, stroke: '#000', 'strokeDashArray': '0', 'strokeDashOffset': 0\n  },\n  'point': { fill: '', radius: 0, show: false, stroke: '' },\n  'data': [\n    { x: new Date('2019-08-20T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-21T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-22T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-23T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-24T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-25T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-26T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-27T00:00:00.000Z'), y: 0 }]\n},\n{\n  'label': 'Their Allocation',\n  'line': {\n    'curveType': curveCatmullRom,\n    fill: { fill: 'rgba(0, 169, 123, 0.2)', show: true },\n    show: true, stroke: 'rgb(0, 169, 123)', 'strokeDashArray': '0', 'strokeDashOffset': 0\n  },\n  'point': { fill: '', radius: 0, show: false, stroke: '' }, 'data': [\n    { x: new Date('2019-08-20T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-21T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-22T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-23T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-24T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-25T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-26T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-27T00:00:00.000Z'), y: 0 }]\n}, {\n  'label': 'Theirs',\n  'line': {\n    'curveType': curveCatmullRom,\n    fill: { fill: 'rgba(0, 169, 123, 0.7)', show: true },\n    show: true, stroke: '#000', 'strokeDashArray': '0', 'strokeDashOffset': 0\n  },\n  'point': { fill: '', radius: 0, show: false, stroke: '' }, 'data': [\n    { x: new Date('2019-08-20T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-21T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-22T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-23T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-24T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-25T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-26T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-27T00:00:00.000Z'), y: 0 }]\n}];\n\nexport const tornadoData: ITornadoData = {\n  bins: ['16-18', '18-25', '25-35', '35-50', '50-65', '65-'],\n  counts: [\n    {\n      label: 'Background',\n      data: [\n        [200, 2600, 5100, 9700, 8400, 6700], // Male bin 1, Male bin 2,\n        [2002, 2100, 4700, 8700, 4900, 1400], // Female bin 1, Female bin 2,\n      ],\n    },\n    {\n      label: 'Foreground',\n      data: [\n        [100, 260, 510, 970, 840, 670], // Male bin 1, Male bin 2,\n        [1000, 5500, 470, 870, 490, 140], // Female bin 1, Female bin 2,\n      ],\n    },\n\n  ],\n}\nexport const scatterData: IScatterPlotDataSet<IChartPointValue> = {\n  label: 'Scatter data',\n  point: { fill: '#000', radius: 4, show: true, stroke: '' },\n  data: [\n    { x: 0, y: 1, z: 5 },\n    { x: 2, y: 1, z: 5 },\n    { x: 3, y: 3, z: 10 },\n    { x: 4, y: 4, z: 5 },\n    { x: 5, y: 1, z: 15 },\n    { x: 6, y: 6, z: 5 },\n    { x: 7, y: 7, z: 15 },\n  ]\n}\n\nexport const radarData: IRadarChartData[] = [{\n  label: 'Germany',\n  axes: [\n    { axis: \"strength\", value: 13 },\n    { axis: \"intelligence\", value: 6 },\n    { axis: \"charisma\", value: 5 },\n    { axis: \"dexterity\", value: 9 },\n    { axis: \"luck\", value: 2 }\n  ]\n},\n{\n  label: 'Argentina',\n  axes: [\n    { axis: \"strength\", value: 6 },\n    { axis: \"intelligence\", value: 7 },\n    { axis: \"charisma\", value: 10 },\n    { axis: \"dexterity\", value: 13 },\n    { axis: \"luck\", value: 9 }\n  ]\n}];\n"],"sourceRoot":""}